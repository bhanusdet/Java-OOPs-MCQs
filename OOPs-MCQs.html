<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🚀 Java OOPs MCQs - Interactive Quiz</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --background-color: #f8f9fa;
            --text-color: #2c3e50;
            --border-color: #e0e6ed;
            --code-bg: #f4f4f4;
            --answer-bg: #d4edda;
            --explanation-bg: #fff3cd;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
        }

        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            height: 8px;
            border-radius: 4px;
            margin-top: 20px;
            overflow: hidden;
        }

        .progress-fill {
            background: white;
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .content {
            padding: 40px;
        }

        .question-container {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .question-container.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .question-header {
            background: var(--secondary-color);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .question-number {
            font-size: 1rem;
            font-weight: 600;
            opacity: 0.9;
        }

        .question-title {
            font-size: 1.1rem;
            font-weight: 500;
            margin-bottom: 15px;
        }

        .question-text {
            margin-bottom: 20px;
            font-size: 1rem;
            line-height: 1.6;
        }

        .code-block {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .options {
            margin: 25px 0;
        }

        .option {
            padding: 15px 20px;
            margin: 12px 0;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: #fdfdfd;
            transition: all 0.3s ease;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .option:hover {
            background: #e3f2fd;
            border-color: var(--secondary-color);
            transform: translateX(5px);
        }

        .option.selected {
            background: #e3f2fd;
            border-color: var(--secondary-color);
            font-weight: 500;
        }

        .answer-section {
            margin-top: 30px;
            display: none;
        }

        .answer-section.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .answer {
            background: var(--answer-bg);
            border: 1px solid var(--success-color);
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }

        .answer-label {
            font-weight: 700;
            color: var(--success-color);
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .explanation {
            background: var(--explanation-bg);
            border: 1px solid var(--warning-color);
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
        }

        .explanation-label {
            font-weight: 700;
            color: var(--warning-color);
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid var(--border-color);
        }

        .nav-button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 120px;
        }

        .nav-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .prev-button {
            background: #3498db;
            color: white;
        }

        .prev-button:hover:not(:disabled) {
            background: #2980b9;
            transform: translateX(-2px);
        }

        .next-button {
            background: var(--secondary-color);
            color: white;
        }

        .next-button:hover:not(:disabled) {
            background: var(--primary-color);
            transform: translateX(2px);
        }

        .show-answer-button {
            background: var(--warning-color);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .show-answer-button:hover {
            background: #e67e22;
            transform: translateY(-1px);
        }

        .question-info {
            text-align: center;
            color: #666;
            font-size: 0.9rem;
        }

        .completion-message {
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            margin: 20px 0;
            display: none;
        }

        .completion-message.show {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }

        .completion-message h3 {
            font-size: 1.5rem;
            margin-bottom: 15px;
        }

        .restart-button {
            background: white;
            color: var(--primary-color);
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .restart-button:hover {
            background: #f8f9fa;
            transform: translateY(-1px);
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8rem;
            }
            
            .content {
                padding: 20px;
            }
            
            .navigation {
                flex-direction: column;
                gap: 15px;
            }
            
            .nav-button {
                width: 100%;
            }
        }
    
        .option.correct {
            background: #d4edda !important;
            border-color: #27ae60 !important;
            color: #155724;
            font-weight: 600;
        }

        .option.wrong {
            background: #f8d7da !important;
            border-color: #e74c3c !important;
            color: #721c24;
            font-weight: 600;
        }

        .option.correct::after {
            content: " ✓";
            color: #27ae60;
            font-weight: bold;
            float: right;
        }

        .option.wrong::after {
            content: " ✗";
            color: #e74c3c;
            font-weight: bold;
            float: right;
        }

        .feedback-enabled .option:not(.correct):not(.wrong) {
            opacity: 0.6;
        }

        .shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .pulse-correct {
            animation: pulseCorrect 0.6s ease-in-out;
        }

        @keyframes pulseCorrect {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Java OOPs MCQs - Interactive Quiz</h1>
            <p>Navigate through Java Object-Oriented Programming questions one at a time with interactive features.</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="content">
            <div id="questionContainer">
                <!-- Questions will be populated by JavaScript -->
            </div>

            <div class="completion-message" id="completionMessage">
                <h3>🎉 Congratulations!</h3>
                <p>You've completed all 93 questions!</p>
                <p>Great job on finishing the MCQ collection.</p>
                <button class="restart-button" onclick="restartQuiz()">Start Over</button>
            </div>

            <div class="navigation" id="navigation">
                <button class="nav-button prev-button" id="prevButton" onclick="previousQuestion()">
                    ← Previous
                </button>
                
                <div class="question-info" id="questionInfo">
                    Question 1 of 93
                </div>
                
                <button class="nav-button next-button" id="nextButton" onclick="nextQuestion()">
                    Next →
                </button>
            </div>
        </div>
    </div>

    <script>
        
        // Using JSON.parse instead of template literals to avoid escaping issues
        const questionsData = [
        {
                "title": "1. Which of the following is NOT a pillar of Object-Oriented Programming?",
                "text": "",
                "code": "",
                "options": [
                        "a) Encapsulation",
                        "b) Inheritance",
                        "c) Compilation",
                        "d) Polymorphism"
                ],
                "answer": "c) Compilation",
                "explanation": "The four pillars of OOP are Encapsulation, Inheritance, Polymorphism, and Abstraction.",
                "correct_index": 2
        },
        {
                "title": "2. What is the output of the following code?",
                "text": "",
                "code": "class Parent {\n    void display() { System.out.println(\"Parent\"); }\n}\nclass Child extends Parent {\n    void display() { System.out.println(\"Child\"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Parent p = new Child();\n        p.display();\n    }\n}",
                "options": [
                        "a) Parent",
                        "b) Child",
                        "c) Compilation Error",
                        "d) Runtime Error"
                ],
                "answer": "b) Child",
                "explanation": "This demonstrates runtime polymorphism. The method called is determined by the actual object type (Child), not the reference type (Parent).",
                "correct_index": 1
        },
        {
                "title": "3. Which access modifier allows access within the same package and subclasses?",
                "text": "",
                "code": "",
                "options": [
                        "a) private",
                        "b) default",
                        "c) protected",
                        "d) public"
                ],
                "answer": "c) protected",
                "explanation": "Protected members are accessible within the same package and by subclasses even if they're in different packages.",
                "correct_index": 2
        },
        {
                "title": "4. What will be the output?",
                "text": "",
                "code": "class A {\n    static { System.out.print(\"A\"); }\n    { System.out.print(\"a\"); }\n}\nclass B extends A {\n    static { System.out.print(\"B\"); }\n    { System.out.print(\"b\"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new B();\n    }\n}",
                "options": [
                        "a) AaBb",
                        "b) ABab",
                        "c) aAbB",
                        "d) BbAa"
                ],
                "answer": "b) ABab",
                "explanation": "Static blocks execute when class is loaded (parent first), then instance blocks during object creation (parent first).",
                "correct_index": 1
        },
        {
                "title": "5. Which of the following is true about abstract classes?",
                "text": "",
                "code": "",
                "options": [
                        "a) Cannot have constructors",
                        "b) Cannot be instantiated directly",
                        "c) Cannot have concrete methods",
                        "d) Must have at least one abstract method"
                ],
                "answer": "b) Cannot be instantiated directly",
                "explanation": "Abstract classes can have constructors, concrete methods, and don't need abstract methods, but cannot be instantiated using new keyword.",
                "correct_index": 1
        },
        {
                "title": "6. What is the output?",
                "text": "",
                "code": "class Parent {\n    Parent() { System.out.print(\"P\"); }\n}\nclass Child extends Parent {\n    Child() { System.out.print(\"C\"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new Child();\n    }\n}",
                "options": [
                        "a) PC",
                        "b) CP",
                        "c) P",
                        "d) C"
                ],
                "answer": "a) PC",
                "explanation": "Parent constructor is called first (implicitly via super()), then child constructor executes.",
                "correct_index": 0
        },
        {
                "title": "7. Which keyword is used to prevent method overriding?",
                "text": "",
                "code": "",
                "options": [
                        "a) static",
                        "b) final",
                        "c) abstract",
                        "d) synchronized"
                ],
                "answer": "b) final",
                "explanation": "Final methods cannot be overridden by subclasses.",
                "correct_index": 1
        },
        {
                "title": "8. What will happen when this code is compiled and run?",
                "text": "",
                "code": "interface A {\n    default void method() { System.out.println(\"A\"); }\n}\ninterface B {\n    default void method() { System.out.println(\"B\"); }\n}\nclass C implements A, B {\n    // Empty class body\n}",
                "options": [
                        "a) Compiles and runs successfully",
                        "b) Compilation error due to ambiguous method",
                        "c) Runtime error",
                        "d) Prints both A and B"
                ],
                "answer": "b) Compilation error due to ambiguous method",
                "explanation": "When implementing multiple interfaces with same default method signature, the class must override the method to resolve ambiguity.",
                "correct_index": 1
        },
        {
                "title": "9. Which of the following demonstrates tight coupling?",
                "text": "",
                "code": "",
                "options": [
                        "a) Using interfaces",
                        "b) Using composition",
                        "c) Direct instantiation of concrete classes",
                        "d) Using dependency injection"
                ],
                "answer": "c) Direct instantiation of concrete classes",
                "explanation": "Tight coupling occurs when classes are directly dependent on concrete implementations rather than abstractions.",
                "correct_index": 2
        },
        {
                "title": "10. What is the output?",
                "text": "",
                "code": "class Test {\n    static int x = 10;\n    static {\n        x = 20;\n        System.out.print(x + \" \");\n    }\n    public static void main(String[] args) {\n        System.out.print(x);\n    }\n}",
                "options": [
                        "a) 10 20",
                        "b) 20 10",
                        "c) 20 20",
                        "d) 10 10"
                ],
                "answer": "c) 20 20",
                "explanation": "Static block executes first, setting x to 20, then main method prints the current value of x.",
                "correct_index": 2
        },
        {
                "title": "11. Which principle suggests \"Program to interfaces, not implementations\"?",
                "text": "",
                "code": "",
                "options": [
                        "a) Single Responsibility Principle",
                        "b) Open/Closed Principle",
                        "c) Dependency Inversion Principle",
                        "d) Interface Segregation Principle"
                ],
                "answer": "c) Dependency Inversion Principle",
                "explanation": "DIP states that high-level modules should not depend on low-level modules; both should depend on abstractions.",
                "correct_index": 2
        },
        {
                "title": "12. What is the difference between method overloading and method overriding?",
                "text": "",
                "code": "",
                "options": [
                        "a) Overloading is compile-time, overriding is runtime",
                        "b) Overloading is runtime, overriding is compile-time",
                        "c) Both are compile-time",
                        "d) Both are runtime"
                ],
                "answer": "a) Overloading is compile-time, overriding is runtime",
                "explanation": "Method overloading is resolved at compile time (static polymorphism), while method overriding is resolved at runtime (dynamic polymorphism).",
                "correct_index": 0
        },
        {
                "title": "13. What will be the output?",
                "text": "",
                "code": "class Animal {\n    void sound() { System.out.println(\"Animal sound\"); }\n}\nclass Dog extends Animal {\n    void sound() { System.out.println(\"Bark\"); }\n    void sound(String type) { System.out.println(\"Loud bark\"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        Dog d = new Dog();\n        a.sound();\n        d.sound(\"loud\");\n    }\n}",
                "options": [
                        "a) Animal sound, Loud bark",
                        "b) Bark, Loud bark",
                        "c) Compilation error",
                        "d) Animal sound, Bark"
                ],
                "answer": "b) Bark, Loud bark",
                "explanation": "First call uses overriding (runtime polymorphism), second call uses overloading (compile-time polymorphism).",
                "correct_index": 1
        },
        {
                "title": "14. Which of the following is true about interfaces in Java 8+?",
                "text": "",
                "code": "",
                "options": [
                        "a) Can have only abstract methods",
                        "b) Can have default and static methods",
                        "c) Cannot have variables",
                        "d) Cannot extend other interfaces"
                ],
                "answer": "b) Can have default and static methods",
                "explanation": "Java 8 introduced default and static methods in interfaces, along with traditional abstract methods.",
                "correct_index": 1
        },
        {
                "title": "15. What is the output?",
                "text": "",
                "code": "class Outer {\n    static int x = 10;\n    static class Inner {\n        static int x = 20;\n        static void display() {\n            System.out.println(x);\n        }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Outer.Inner.display();\n    }\n}",
                "options": [
                        "a) 10",
                        "b) 20",
                        "c) Compilation error",
                        "d) 0"
                ],
                "answer": "b) 20",
                "explanation": "The inner class's x variable shadows the outer class's x variable within the inner class scope.",
                "correct_index": 1
        },
        {
                "title": "16. Which design pattern ensures only one instance of a class exists?",
                "text": "",
                "code": "",
                "options": [
                        "a) Factory",
                        "b) Singleton",
                        "c) Builder",
                        "d) Observer"
                ],
                "answer": "b) Singleton",
                "explanation": "Singleton pattern ensures a class has only one instance and provides global access to it.",
                "correct_index": 1
        },
        {
                "title": "17. What will be the output?",
                "text": "",
                "code": "class Parent {\n    static void method() { System.out.println(\"Parent static\"); }\n}\nclass Child extends Parent {\n    static void method() { System.out.println(\"Child static\"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Parent p = new Child();\n        p.method();\n    }\n}",
                "options": [
                        "a) Parent static",
                        "b) Child static",
                        "c) Compilation error",
                        "d) Runtime error"
                ],
                "answer": "a) Parent static",
                "explanation": "Static methods are resolved at compile time based on the reference type, not the object type. This is method hiding, not overriding.",
                "correct_index": 0
        },
        {
                "title": "18. Which of the following violates encapsulation?",
                "text": "",
                "code": "",
                "options": [
                        "a) Making fields private",
                        "b) Providing public getter/setter methods",
                        "c) Making fields public",
                        "d) Using constructors to initialize fields"
                ],
                "answer": "c) Making fields public",
                "explanation": "Public fields directly expose internal state, violating encapsulation principles.",
                "correct_index": 2
        },
        {
                "title": "19. What is the output?",
                "text": "",
                "code": "interface I1 {\n    default void method() { System.out.print(\"I1 \"); }\n}\ninterface I2 extends I1 {\n    default void method() { System.out.print(\"I2 \"); }\n}\nclass Test implements I2 {\n    public static void main(String[] args) {\n        new Test().method();\n    }\n}",
                "options": [
                        "a) I1",
                        "b) I2",
                        "c) I1 I2",
                        "d) Compilation error"
                ],
                "answer": "b) I2",
                "explanation": "When interfaces extend other interfaces, the subinterface's default method overrides the parent's default method.",
                "correct_index": 1
        },
        {
                "title": "20. Which keyword is used to call parent class constructor explicitly?",
                "text": "",
                "code": "",
                "options": [
                        "a) this",
                        "b) super",
                        "c) parent",
                        "d) base"
                ],
                "answer": "b) super",
                "explanation": "super() is used to call the parent class constructor explicitly.",
                "correct_index": 1
        },
        {
                "title": "21. What will be the output?",
                "text": "",
                "code": "class Test {\n    int x = 10;\n    Test() {\n        this(20);\n        System.out.print(x + \" \");\n    }\n    Test(int x) {\n        this.x = x;\n        System.out.print(x + \" \");\n    }\n    public static void main(String[] args) {\n        new Test();\n    }\n}",
                "options": [
                        "a) 10 20",
                        "b) 20 20",
                        "c) 20 10",
                        "d) Compilation error"
                ],
                "answer": "b) 20 20",
                "explanation": "Constructor chaining: Test() calls Test(20), which sets x=20, then prints 20, then control returns to Test() which prints current x value (20).",
                "correct_index": 1
        },
        {
                "title": "22. Which of the following is true about composition vs inheritance?",
                "text": "",
                "code": "",
                "options": [
                        "a) Composition is \"is-a\" relationship",
                        "b) Inheritance is \"has-a\" relationship",
                        "c) Composition provides better flexibility",
                        "d) Inheritance is always preferred"
                ],
                "answer": "c) Composition provides better flexibility",
                "explanation": "Composition allows changing behavior at runtime and avoids tight coupling issues of inheritance.",
                "correct_index": 2
        },
        {
                "title": "23. What is the output?",
                "text": "",
                "code": "abstract class Animal {\n    abstract void sound();\n    void sleep() { System.out.println(\"Sleeping\"); }\n}\nclass Dog extends Animal {\n    void sound() { System.out.println(\"Bark\"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.sound();\n        a.sleep();\n    }\n}",
                "options": [
                        "a) Compilation error",
                        "b) Bark, Sleeping",
                        "c) Runtime error",
                        "d) Sleeping, Bark"
                ],
                "answer": "b) Bark, Sleeping",
                "explanation": "Abstract classes can be referenced, and both abstract and concrete methods can be called on the subclass object.",
                "correct_index": 1
        },
        {
                "title": "24. Which access modifier provides the most restrictive access?",
                "text": "",
                "code": "",
                "options": [
                        "a) private",
                        "b) default",
                        "c) protected",
                        "d) public"
                ],
                "answer": "a) private",
                "explanation": "Private members are accessible only within the same class, making it the most restrictive access level.",
                "correct_index": 0
        },
        {
                "title": "25. What will be the output?",
                "text": "",
                "code": "class Parent {\n    void display() throws Exception {\n        System.out.println(\"Parent\");\n    }\n}\nclass Child extends Parent {\n    void display() throws RuntimeException {\n        System.out.println(\"Child\");\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Parent p = new Child();\n        p.display(); // Line X\n    }\n}",
                "options": [
                        "a) Parent",
                        "b) Child",
                        "c) Compilation error at Line X",
                        "d) Runtime error"
                ],
                "answer": "c) Compilation error at Line X",
                "explanation": "The reference type (Parent) declares checked exception, so the call must be in try-catch or method must declare throws Exception.",
                "correct_index": 2
        },
        {
                "title": "26. Which principle states \"Classes should be open for extension but closed for modification\"?",
                "text": "",
                "code": "",
                "options": [
                        "a) Single Responsibility Principle",
                        "b) Open/Closed Principle",
                        "c) Liskov Substitution Principle",
                        "d) Dependency Inversion Principle"
                ],
                "answer": "b) Open/Closed Principle",
                "explanation": "OCP states that software entities should be open for extension but closed for modification.",
                "correct_index": 1
        },
        {
                "title": "27. What is the output?",
                "text": "",
                "code": "class Test {\n    Test() {\n        System.out.print(\"A\");\n    }\n    Test(int x) {\n        this();\n        System.out.print(\"B\");\n    }\n    {\n        System.out.print(\"C\");\n    }\n    static {\n        System.out.print(\"D\");\n    }\n    public static void main(String[] args) {\n        new Test(10);\n    }\n}",
                "options": [
                        "a) DCAB",
                        "b) DACB",
                        "c) DCBA",
                        "d) CABD"
                ],
                "answer": "a) DCAB",
                "explanation": "Static block (D), then instance block (C), then Test() via this() (A), then Test(int) continues (B).",
                "correct_index": 0
        },
        {
                "title": "28. Which of the following allows multiple inheritance in Java?",
                "text": "",
                "code": "",
                "options": [
                        "a) Classes",
                        "b) Abstract classes",
                        "c) Interfaces",
                        "d) None of the above"
                ],
                "answer": "c) Interfaces",
                "explanation": "A class can implement multiple interfaces, achieving multiple inheritance of type.",
                "correct_index": 2
        },
        {
                "title": "29. What will be the output?",
                "text": "",
                "code": "class Parent {\n    int x = 10;\n}\nclass Child extends Parent {\n    int x = 20;\n    void display() {\n        System.out.println(x + \" \" + super.x);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new Child().display();\n    }\n}",
                "options": [
                        "a) 10 10",
                        "b) 20 20",
                        "c) 20 10",
                        "d) 10 20"
                ],
                "answer": "c) 20 10",
                "explanation": "x refers to child's field (20), super.x refers to parent's field (10). This is field hiding.",
                "correct_index": 2
        },
        {
                "title": "30. Which modifier prevents a class from being subclassed?",
                "text": "",
                "code": "",
                "options": [
                        "a) static",
                        "b) final",
                        "c) abstract",
                        "d) private"
                ],
                "answer": "b) final",
                "explanation": "Final classes cannot be extended (e.g., String, Integer classes are final).",
                "correct_index": 1
        },
        {
                "title": "31. What is the output?",
                "text": "",
                "code": "interface A {\n    int x = 10; // Line 1\n}\nclass B implements A {\n    public static void main(String[] args) {\n        x = 20; // Line 2\n        System.out.println(x);\n    }\n}",
                "options": [
                        "a) 20",
                        "b) 10",
                        "c) Compilation error at Line 1",
                        "d) Compilation error at Line 2"
                ],
                "answer": "d) Compilation error at Line 2",
                "explanation": "Interface variables are implicitly public static final, so they cannot be reassigned.",
                "correct_index": 3
        },
        {
                "title": "32. Which concept allows treating objects of different types uniformly?",
                "text": "",
                "code": "",
                "options": [
                        "a) Encapsulation",
                        "b) Inheritance",
                        "c) Polymorphism",
                        "d) Abstraction"
                ],
                "answer": "c) Polymorphism",
                "explanation": "Polymorphism allows objects of different types to be treated uniformly through a common interface or base class.",
                "correct_index": 2
        },
        {
                "title": "33. What will be the output?",
                "text": "",
                "code": "class Outer {\n    int x = 10;\n    class Inner {\n        int x = 20;\n        void display() {\n            int x = 30;\n            System.out.println(x + \" \" + this.x + \" \" + Outer.this.x);\n        }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new Outer().new Inner().display();\n    }\n}",
                "options": [
                        "a) 10 20 30",
                        "b) 30 20 10",
                        "c) 30 30 30",
                        "d) 20 10 30"
                ],
                "answer": "b) 30 20 10",
                "explanation": "Local variable x (30), inner class field this.x (20), outer class field Outer.this.x (10).",
                "correct_index": 1
        },
        {
                "title": "34. Which of the following is NOT a valid way to achieve polymorphism?",
                "text": "",
                "code": "",
                "options": [
                        "a) Method overriding",
                        "b) Method overloading",
                        "c) Interface implementation",
                        "d) Variable hiding"
                ],
                "answer": "d) Variable hiding",
                "explanation": "Variable hiding is not polymorphism. Polymorphism is achieved through method overriding, overloading, and interface implementation.",
                "correct_index": 3
        },
        {
                "title": "35. What is the output?",
                "text": "",
                "code": "class Test {\n    static int count = 0;\n    Test() {\n        count++;\n        System.out.print(count + \" \");\n    }\n    public static void main(String[] args) {\n        new Test();\n        new Test();\n        new Test();\n    }\n}",
                "options": [
                        "a) 1 1 1",
                        "b) 3 3 3",
                        "c) 1 2 3",
                        "d) 0 1 2"
                ],
                "answer": "c) 1 2 3",
                "explanation": "Static variable count is shared among all instances and incremented each time a new object is created.",
                "correct_index": 2
        },
        {
                "title": "36. Which relationship is represented by composition?",
                "text": "",
                "code": "",
                "options": [
                        "a) is-a",
                        "b) has-a",
                        "c) uses-a",
                        "d) implements-a"
                ],
                "answer": "b) has-a",
                "explanation": "Composition represents a \"has-a\" relationship where one object contains another object as part of its state.",
                "correct_index": 1
        },
        {
                "title": "37. What will be the output?",
                "text": "",
                "code": "class Parent {\n    static void method() { System.out.print(\"Parent \"); }\n    void instance() { method(); }\n}\nclass Child extends Parent {\n    static void method() { System.out.print(\"Child \"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Parent p = new Child();\n        p.instance();\n        p.method();\n    }\n}",
                "options": [
                        "a) Parent Parent",
                        "b) Child Child",
                        "c) Child Parent",
                        "d) Parent Child"
                ],
                "answer": "c) Child Parent",
                "explanation": "instance() calls method() dynamically (Child), but p.method() calls statically based on reference type (Parent).",
                "correct_index": 2
        },
        {
                "title": "38. Which principle suggests that objects should be replaceable with instances of their subtypes?",
                "text": "",
                "code": "",
                "options": [
                        "a) Open/Closed Principle",
                        "b) Liskov Substitution Principle",
                        "c) Interface Segregation Principle",
                        "d) Dependency Inversion Principle"
                ],
                "answer": "b) Liskov Substitution Principle",
                "explanation": "LSP states that objects of a superclass should be replaceable with objects of a subclass without affecting functionality.",
                "correct_index": 1
        },
        {
                "title": "39. What is the output?",
                "text": "",
                "code": "class Test {\n    public Test() {\n        System.out.print(\"Default \");\n    }\n    public Test(String s) {\n        System.out.print(\"String \");\n    }\n    public static void main(String[] args) {\n        new Test();\n        new Test(\"Hello\");\n        new Test(null);\n    }\n}",
                "options": [
                        "a) Default String String",
                        "b) Default String Default",
                        "c) Compilation error",
                        "d) Default String Compilation error"
                ],
                "answer": "c) Compilation error",
                "explanation": "new Test(null) is ambiguous because null can match both String and any other reference type parameter if there were another constructor.",
                "correct_index": 2
        },
        {
                "title": "40. Which of the following breaks encapsulation?",
                "text": "",
                "code": "",
                "options": [
                        "a) Using private fields with public getters",
                        "b) Returning mutable objects directly from getters",
                        "c) Using constructor injection",
                        "d) Validating input in setters"
                ],
                "answer": "b) Returning mutable objects directly from getters",
                "explanation": "Returning mutable objects allows external modification of internal state, breaking encapsulation.",
                "correct_index": 1
        },
        {
                "title": "41. What will be the output?",
                "text": "",
                "code": "abstract class Animal {\n    public Animal() { System.out.print(\"Animal \"); }\n}\nclass Dog extends Animal {\n    public Dog() { System.out.print(\"Dog \"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n    }\n}",
                "options": [
                        "a) Animal Dog",
                        "b) Dog Animal",
                        "c) Dog",
                        "d) Animal"
                ],
                "answer": "a) Animal Dog",
                "explanation": "Parent constructor (Animal) is called first, then child constructor (Dog).",
                "correct_index": 0
        },
        {
                "title": "42. Which keyword is used to refer to the current object?",
                "text": "",
                "code": "",
                "options": [
                        "a) self",
                        "b) current",
                        "c) this",
                        "d) me"
                ],
                "answer": "c) this",
                "explanation": "'this' keyword refers to the current object instance in Java.",
                "correct_index": 2
        },
        {
                "title": "43. What is the output?",
                "text": "",
                "code": "class Test {\n    int x;\n    Test(int x) {\n        x = x; // Line 1\n    }\n    public static void main(String[] args) {\n        Test t = new Test(10);\n        System.out.println(t.x);\n    }\n}",
                "options": [
                        "a) 10",
                        "b) 0",
                        "c) Compilation error",
                        "d) Runtime error"
                ],
                "answer": "b) 0",
                "explanation": "Line 1 assigns parameter x to itself, not to instance variable. Instance variable x remains 0 (default value).",
                "correct_index": 1
        },
        {
                "title": "44. Which of the following is true about method overriding?",
                "text": "",
                "code": "",
                "options": [
                        "a) Private methods can be overridden",
                        "b) Static methods can be overridden",
                        "c) Final methods can be overridden",
                        "d) Protected methods can be overridden"
                ],
                "answer": "d) Protected methods can be overridden",
                "explanation": "Protected methods can be overridden. Private, static, and final methods cannot be overridden.",
                "correct_index": 3
        },
        {
                "title": "45. What will be the output?",
                "text": "",
                "code": "interface I {\n    void method();\n}\nclass A implements I {\n    public void method() { System.out.print(\"A \"); }\n}\nclass B extends A {\n    public void method() { System.out.print(\"B \"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        I i = new B();\n        A a = new B();\n        i.method();\n        a.method();\n    }\n}",
                "options": [
                        "a) A A",
                        "b) B B",
                        "c) A B",
                        "d) B A"
                ],
                "answer": "b) B B",
                "explanation": "Both calls use runtime polymorphism, calling B's overridden method regardless of reference type.",
                "correct_index": 1
        },
        {
                "title": "46. Which design pattern is used to create objects without specifying exact class?",
                "text": "",
                "code": "",
                "options": [
                        "a) Singleton",
                        "b) Factory",
                        "c) Observer",
                        "d) Strategy"
                ],
                "answer": "b) Factory",
                "explanation": "Factory pattern creates objects without exposing creation logic and refers to newly created object using common interface.",
                "correct_index": 1
        },
        {
                "title": "47. What is the output?",
                "text": "",
                "code": "class Outer {\n    static class Nested {\n        void display() { System.out.print(\"Nested \"); }\n    }\n    class Inner {\n        void display() { System.out.print(\"Inner \"); }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new Outer.Nested().display();\n        new Outer().new Inner().display();\n    }\n}",
                "options": [
                        "a) Nested Inner",
                        "b) Inner Nested",
                        "c) Compilation error",
                        "d) Inner Inner"
                ],
                "answer": "a) Nested Inner",
                "explanation": "Static nested class can be instantiated without outer instance, but inner class needs outer instance.",
                "correct_index": 0
        },
        {
                "title": "48. Which principle suggests that a class should have only one reason to change?",
                "text": "",
                "code": "",
                "options": [
                        "a) Single Responsibility Principle",
                        "b) Open/Closed Principle",
                        "c) Liskov Substitution Principle",
                        "d) Interface Segregation Principle"
                ],
                "answer": "a) Single Responsibility Principle",
                "explanation": "SRP states that a class should have only one reason to change, meaning it should have only one job or responsibility.",
                "correct_index": 0
        },
        {
                "title": "49. What will be the output?",
                "text": "",
                "code": "class Test {\n    void method(Object o) { System.out.print(\"Object \"); }\n    void method(String s) { System.out.print(\"String \"); }\n    public static void main(String[] args) {\n        Test t = new Test();\n        t.method(\"Hello\");\n        t.method((Object)\"Hello\");\n        t.method(null);\n    }\n}",
                "options": [
                        "a) String Object String",
                        "b) String Object Object",
                        "c) Object String String",
                        "d) String String String"
                ],
                "answer": "a) String Object String",
                "explanation": "First call matches String (most specific), second call explicitly casts to Object, third call matches String (more specific than Object for null).",
                "correct_index": 0
        },
        {
                "title": "50. Which of the following best describes abstraction?",
                "text": "",
                "code": "",
                "options": [
                        "a) Hiding implementation details",
                        "b) Creating multiple objects",
                        "c) Inheriting from parent class",
                        "d) Accessing private members"
                ],
                "answer": "a) Hiding implementation details",
                "explanation": "Abstraction is the concept of hiding complex implementation details while exposing only essential features of an object.",
                "correct_index": 0
        },
        {
                "title": "What is the output of this code?",
                "text": "",
                "code": "class Parent {\n    static String name = \"Parent\";\n    static {\n        name = getName();\n    }\n    static String getName() {\n        return \"ParentStatic\";\n    }\n}\nclass Child extends Parent {\n    static String name = \"Child\";\n    static {\n        name = getName();\n    }\n    static String getName() {\n        return \"ChildStatic\";\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(Parent.name + \" \" + Child.name);\n    }\n}",
                "options": [
                        "a) Parent Child",
                        "b) ParentStatic ChildStatic",
                        "c) ChildStatic ChildStatic",
                        "d) ParentStatic ParentStatic"
                ],
                "answer": "c) ChildStatic ChildStatic",
                "explanation": "During Child loading, Parent's static block executes, but it calls getName(), which is resolved dynamically to Child.getName(). Hence both become \"ChildStatic\". This tests class loading + static initialization + method hiding.",
                "correct_index": 2
        },
        {
                "title": "What is the output of this code?",
                "text": "",
                "code": "class A {\n    int value = 10;\n    A() {\n        System.out.println(\"A constructor, value = \" + value);\n        print();\n    }\n    void print() {\n        System.out.println(\"A print, value = \" + value);\n    }\n}\nclass B extends A {\n    int value = 20;\n    B() {\n        System.out.println(\"B constructor, value = \" + value);\n    }\n    void print() {\n        System.out.println(\"B print, value = \" + value);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new B();\n    }\n}",
                "options": [
                        "a) A constructor, value = 10",
                        "b) A constructor, value = 10",
                        "c) A constructor, value = 10",
                        "d) Compilation error"
                ],
                "answer": "b)",
                "explanation": "During A's constructor, B.print() is invoked (dynamic dispatch). At this point, B.value is not initialized yet, so it prints 0. Later, B's constructor assigns 20. Classic constructor chaining + polymorphism + initialization order trap.",
                "correct_index": -1
        },
        {
                "title": "What is the output of this code?",
                "text": "",
                "code": "class Base {\n    String msg = \"Base\";\n    Base() {\n        show();\n    }\n    void show() {\n        System.out.println(msg);\n    }\n}\nclass Derived extends Base {\n    String msg = \"Derived\";\n    Derived() {\n        show();\n    }\n    void show() {\n        System.out.println(msg);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new Derived();\n    }\n}",
                "options": [
                        "a) Base",
                        "b) null",
                        "c) Derived",
                        "d) Base"
                ],
                "answer": "b) null, Derived",
                "explanation": "When Base constructor calls show(), it invokes Derived.show(). But Derived.msg is not yet initialized (defaults to null). Later, after initialization, second call prints \"Derived\". Tests field initialization order vs. polymorphism.",
                "correct_index": -1
        },
        {
                "title": "What is the output of this code?",
                "text": "",
                "code": "class A {\n    static void display() { System.out.println(\"A\"); }\n}\nclass B extends A {\n    static void display() { System.out.println(\"B\"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        A obj = new B();\n        obj.display();\n    }\n}",
                "options": [
                        "a) A",
                        "b) B",
                        "c) Compilation error",
                        "d) Runtime error"
                ],
                "answer": "a) A",
                "explanation": "static methods are hidden, not overridden. Resolution happens at compile-time using reference type (A). A common method hiding vs. overriding interview trick.",
                "correct_index": 0
        },
        {
                "title": "What is the output of this code?",
                "text": "",
                "code": "class Outer {\n    private static String secret = \"Hidden\";\n    static class Inner {\n        void reveal() {\n            System.out.println(secret);\n        }\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new Outer.Inner().reveal();\n    }\n}",
                "options": [
                        "a) Compilation error",
                        "b) null",
                        "c) Hidden",
                        "d) Runtime error"
                ],
                "answer": "c) Hidden",
                "explanation": "A static nested class can access private static members of the outer class. This tests nested class access rules.",
                "correct_index": 2
        },
        {
                "title": "What is the output of this code?",
                "text": "",
                "code": "class A {\n    final void foo() { System.out.println(\"A.foo\"); }\n}\nclass B extends A {\n    void foo(int x) { System.out.println(\"B.foo\"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new B().foo();\n    }\n}",
                "options": [
                        "a) A.foo",
                        "b) B.foo",
                        "c) Compilation error",
                        "d) Runtime error"
                ],
                "answer": "a) A.foo",
                "explanation": "foo() in A is final and cannot be overridden. B only overloads it with foo(int). Hence call resolves to A.foo(). Tests overloading vs overriding with final methods.",
                "correct_index": 0
        },
        {
                "title": "What is the output of this code?",
                "text": "",
                "code": "interface I1 {\n    default void show() { System.out.println(\"I1\"); }\n}\ninterface I2 {\n    default void show() { System.out.println(\"I2\"); }\n}\nclass Test implements I1, I2 {\n    public void show() {\n        I1.super.show();\n    }\n    public static void main(String[] args) {\n        new Test().show();\n    }\n}",
                "options": [
                        "a) I1",
                        "b) I2",
                        "c) Compilation error",
                        "d) Both I1 and I2"
                ],
                "answer": "a) I1",
                "explanation": "Multiple inheritance conflict is resolved explicitly. Here, I1.super.show() is chosen. This is default methods diamond problem in Java 8.",
                "correct_index": 0
        },
        {
                "title": "What is the output of this code?",
                "text": "",
                "code": "class A {\n    int x = 10;\n}\nclass B extends A {\n    int x = 20;\n}\npublic class Test {\n    public static void main(String[] args) {\n        A obj = new B();\n        System.out.println(obj.x);\n    }\n}",
                "options": [
                        "a) 10",
                        "b) 20",
                        "c) Compilation error",
                        "d) Runtime error"
                ],
                "answer": "a) 10",
                "explanation": "Fields are not polymorphic. Resolution happens at compile-time by reference type (A). Tests field hiding vs method overriding.",
                "correct_index": 0
        },
        {
                "title": "What is the output of this code?",
                "text": "",
                "code": "class A {\n    static { System.out.println(\"A static\"); }\n    { System.out.println(\"A instance\"); }\n}\nclass B extends A {\n    static { System.out.println(\"B static\"); }\n    { System.out.println(\"B instance\"); }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new B();\n        new B();\n    }\n}",
                "options": [
                        "a) A static",
                        "b) A static",
                        "c) A static",
                        "d) Compilation error"
                ],
                "answer": "a)",
                "explanation": "Static blocks run once per class load, instance blocks run every time an object is created. Classic class loading vs instance initialization.",
                "correct_index": -1
        },
        {
                "title": "What is the output of this code?",
                "text": "",
                "code": "class Test {\n    public static void main(String[] args) {\n        String s1 = new String(\"Java\");\n        String s2 = \"Java\";\n        String s3 = s1.intern();\n        System.out.println(s1 == s2);\n        System.out.println(s2 == s3);\n    }\n}",
                "options": [
                        "a) true",
                        "b) false",
                        "c) true",
                        "d) false"
                ],
                "answer": "b) false, true",
                "explanation": "s1 points to heap object, s2 points to string pool. After intern(), s3 points to pool, same as s2. This checks string interning mechanism.",
                "correct_index": -1
        },
        {
                "title": "1. What is the output of this code?",
                "text": "",
                "code": "class Parent {\n    static String name = \"Parent\";\n    static {\n        name = getName();\n    }\n    static String getName() {\n        return \"ParentStatic\";\n    }\n}\nclass Child extends Parent {\n    static String name = \"Child\";\n    static {\n        name = getName();\n    }\n    static String getName() {\n        return \"ChildStatic\";\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        System.out.println(Parent.name + \" \" + Child.name);\n    }\n}",
                "options": [
                        "a) Parent Child",
                        "b) ParentStatic ChildStatic",
                        "c) ChildStatic ChildStatic",
                        "d) ParentStatic ParentStatic"
                ],
                "answer": "c) ChildStatic ChildStatic",
                "explanation": "When Child class is loaded, Parent's static block calls getName() which is overridden by Child, so both get \"ChildStatic\". This is a classic example of calling overridable methods during static initialization.",
                "correct_index": 2
        },
        {
                "title": "2. What will be the output?",
                "text": "",
                "code": "class Test {\n    private void method() {\n        System.out.println(\"Private method\");\n    }\n    \n    public static void main(String[] args) {\n        Test t1 = new Test();\n        Test t2 = new Test() {\n            public void method() {\n                System.out.println(\"Anonymous method\");\n            }\n        };\n        \n        t1.method();\n        t2.method();\n    }\n}",
                "options": [
                        "a) Private method, Anonymous method",
                        "b) Private method, Private method",
                        "c) Compilation error",
                        "d) Anonymous method, Anonymous method"
                ],
                "answer": "c) Compilation error",
                "explanation": "Anonymous classes cannot override private methods as they're not inherited. The anonymous class creates a new method, but the call t2.method() tries to access the private method from outside the class.",
                "correct_index": 2
        },
        {
                "title": "3. What is the output?",
                "text": "",
                "code": "interface A {\n    default void test() {\n        System.out.print(\"A\");\n    }\n}\ninterface B extends A {\n    default void test() {\n        System.out.print(\"B\");\n        A.super.test();\n    }\n}\ninterface C extends A {\n    default void test() {\n        System.out.print(\"C\");\n        A.super.test();\n    }\n}\nclass D implements B, C {\n    public void test() {\n        B.super.test();\n        C.super.test();\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        new D().test();\n    }\n}",
                "options": [
                        "a) BACA",
                        "b) BCAA",
                        "c) Compilation error",
                        "d) ABAC"
                ],
                "answer": "a) BACA",
                "explanation": "D.test() calls B.super.test() (prints \"B\", then \"A\"), then C.super.test() (prints \"C\", then \"A\").",
                "correct_index": 0
        },
        {
                "title": "4. What will happen when this code runs?",
                "text": "",
                "code": "class Parent {\n    Parent() throws Exception {\n        throw new Exception(\"Parent exception\");\n    }\n}\nclass Child extends Parent {\n    Child() {\n        super();\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            new Child();\n        } catch (Exception e) {\n            System.out.println(\"Caught: \" + e.getMessage());\n        }\n    }\n}",
                "options": [
                        "a) Prints: Caught: Parent exception",
                        "b) Compilation error in Child constructor",
                        "c) Runtime exception",
                        "d) No output"
                ],
                "answer": "b) Compilation error in Child constructor",
                "explanation": "Child constructor must handle or declare the Exception thrown by Parent constructor, but it doesn't have throws clause or try-catch.",
                "correct_index": 1
        },
        {
                "title": "5. What is the output?",
                "text": "",
                "code": "class Outer {\n    int x = 10;\n    \n    class Inner {\n        int x = 20;\n        \n        class InnerInner {\n            int x = 30;\n            \n            void display() {\n                System.out.println(x + \" \" + Inner.this.x + \" \" + Outer.this.x);\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        Outer.Inner.InnerInner obj = new Outer().new Inner().new InnerInner();\n        obj.display();\n    }\n}",
                "options": [
                        "a) 10 20 30",
                        "b) 30 20 10",
                        "c) 30 30 30",
                        "d) Compilation error"
                ],
                "answer": "b) 30 20 10",
                "explanation": "InnerInner's x (30), Inner's x via Inner.this.x (20), Outer's x via Outer.this.x (10).",
                "correct_index": 1
        },
        {
                "title": "6. What will be the output?",
                "text": "",
                "code": "class Test {\n    static {\n        System.out.print(\"1\");\n    }\n    \n    {\n        System.out.print(\"2\");\n    }\n    \n    Test() {\n        System.out.print(\"3\");\n    }\n    \n    Test(int x) {\n        this();\n        System.out.print(\"4\");\n    }\n    \n    public static void main(String[] args) {\n        new Test(5);\n        new Test();\n    }\n}",
                "options": [
                        "a) 123423",
                        "b) 134123",
                        "c) 123234",
                        "d) 132342"
                ],
                "answer": "c) 123234",
                "explanation": "Static block (1), then first object: instance block (2), Test() via this() (3), Test(int) continues (4), then second object: instance block (2), Test() constructor (3).",
                "correct_index": 2
        },
        {
                "title": "7. What is the output?",
                "text": "",
                "code": "abstract class Animal {\n    abstract void sound();\n    \n    Animal() {\n        sound(); // Line X\n    }\n}\n\nclass Dog extends Animal {\n    String breed = \"Labrador\";\n    \n    void sound() {\n        System.out.println(\"Bark: \" + breed);\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        new Dog();\n    }\n}",
                "options": [
                        "a) Bark: Labrador",
                        "b) Bark: null",
                        "c) Compilation error at Line X",
                        "d) Runtime exception"
                ],
                "answer": "b) Bark: null",
                "explanation": "During object construction, parent constructor runs first. At this time, Dog's instance variables haven't been initialized yet, so breed is null.",
                "correct_index": 1
        },
        {
                "title": "8. What will be the output?",
                "text": "",
                "code": "class Parent {\n    void method() throws IOException {\n        System.out.println(\"Parent\");\n    }\n}\n\nclass Child extends Parent {\n    void method() throws FileNotFoundException {\n        System.out.println(\"Child\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Parent p = new Child();\n        try {\n            p.method();\n        } catch (IOException e) {\n            System.out.println(\"IOException caught\");\n        }\n    }\n}",
                "options": [
                        "a) Child",
                        "b) Parent",
                        "c) IOException caught",
                        "d) Compilation error"
                ],
                "answer": "a) Child",
                "explanation": "Method overriding with exception handling. Child's method throws a subtype of IOException (FileNotFoundException), which is valid. Runtime polymorphism calls Child's method.",
                "correct_index": 0
        },
        {
                "title": "9. What is the output?",
                "text": "",
                "code": "class Test {\n    static Test instance = new Test();\n    static int x = 10;\n    \n    Test() {\n        System.out.print(x + \" \");\n    }\n    \n    public static void main(String[] args) {\n        System.out.print(Test.x + \" \");\n        new Test();\n    }\n}",
                "options": [
                        "a) 0 10 10",
                        "b) 10 10 10",
                        "c) 0 0 10",
                        "d) 10 0 10"
                ],
                "answer": "a) 0 10 10",
                "explanation": "Static variables are initialized in order. When `instance = new Test()` executes, x is still 0 (not yet initialized), so constructor prints 0. Then x becomes 10, main prints 10, new Test() prints 10.",
                "correct_index": 0
        },
        {
                "title": "10. What will happen?",
                "text": "",
                "code": "final class FinalClass {\n    void method() {\n        System.out.println(\"Final class method\");\n    }\n}\n\nclass Test {\n    public static void main(String[] args) {\n        FinalClass obj = new FinalClass() {\n            void method() {\n                System.out.println(\"Anonymous method\");\n            }\n        };\n        obj.method();\n    }\n}",
                "options": [
                        "a) Final class method",
                        "b) Anonymous method",
                        "c) Compilation error",
                        "d) Runtime error"
                ],
                "answer": "c) Compilation error",
                "explanation": "Final classes cannot be extended, not even by anonymous classes.",
                "correct_index": 2
        },
        {
                "title": "11. What is the output?",
                "text": "",
                "code": "interface I {\n    int x = 10;\n}\n\nclass A implements I {\n    int x = 20;\n}\n\nclass B extends A {\n    void display() {\n        System.out.println(x + \" \" + super.x + \" \" + I.x);\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        new B().display();\n    }\n}",
                "options": [
                        "a) 20 20 10",
                        "b) 10 20 10",
                        "c) 20 10 10",
                        "d) Compilation error"
                ],
                "answer": "a) 20 20 10",
                "explanation": "x refers to A's field (20), super.x also refers to A's field (20), I.x is interface constant (10).",
                "correct_index": 0
        },
        {
                "title": "12. What will be the output?",
                "text": "",
                "code": "class Parent {\n    String name;\n    Parent(String name) {\n        this.name = name;\n    }\n    \n    void display() {\n        System.out.print(name + \" \");\n    }\n}\n\nclass Child extends Parent {\n    String name;\n    Child(String parentName, String childName) {\n        super(parentName);\n        this.name = childName;\n    }\n    \n    void display() {\n        super.display();\n        System.out.print(this.name + \" \");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Child c = new Child(\"Dad\", \"Son\");\n        c.display();\n    }\n}",
                "options": [
                        "a) Dad Son",
                        "b) Son Dad",
                        "c) Dad Dad",
                        "d) Son Son"
                ],
                "answer": "a) Dad Son",
                "explanation": "super.display() prints parent's name field (\"Dad\"), then prints child's name field (\"Son\").",
                "correct_index": 0
        },
        {
                "title": "13. What is the output?",
                "text": "",
                "code": "class Test {\n    void method(int... args) {\n        System.out.print(\"Varargs \");\n    }\n    \n    void method(int[] args) {\n        System.out.print(\"Array \");\n    }\n    \n    public static void main(String[] args) {\n        Test t = new Test();\n        t.method(new int[]{1, 2, 3});\n        t.method(1, 2, 3);\n    }\n}",
                "options": [
                        "a) Array Varargs",
                        "b) Varargs Array",
                        "c) Compilation error",
                        "d) Array Array"
                ],
                "answer": "c) Compilation error",
                "explanation": "Ambiguous method call. int[] and int... are equivalent at runtime, so the compiler cannot distinguish between them.",
                "correct_index": 2
        },
        {
                "title": "14. What will be the output?",
                "text": "",
                "code": "class Outer {\n    private int x = 10;\n    \n    class Inner {\n        private int x = 20;\n        \n        void test() {\n            System.out.println(\"Inner x: \" + this.x);\n            System.out.println(\"Outer x: \" + Outer.this.x);\n        }\n    }\n    \n    void createInner() {\n        Inner inner = new Inner() {\n            private int x = 30;\n            void test() {\n                System.out.println(\"Anonymous x: \" + this.x);\n                super.test();\n            }\n        };\n        inner.test();\n    }\n    \n    public static void main(String[] args) {\n        new Outer().createInner();\n    }\n}",
                "options": [
                        "a) Anonymous x: 30, Inner x: 20, Outer x: 10",
                        "b) Inner x: 20, Outer x: 10",
                        "c) Anonymous x: 30, Inner x: 30, Outer x: 10",
                        "d) Compilation error"
                ],
                "answer": "a) Anonymous x: 30, Inner x: 20, Outer x: 10",
                "explanation": "Anonymous class overrides test(), prints its own x (30), then calls super.test() which prints Inner's x (20) and Outer's x (10).",
                "correct_index": 0
        },
        {
                "title": "15. What is the output?",
                "text": "",
                "code": "class A {\n    static void method() { System.out.print(\"A\"); }\n}\n\nclass B extends A {\n    static void method() { System.out.print(\"B\"); }\n    \n    static {\n        method(); // Line 1\n    }\n}\n\nclass C extends B {\n    static void method() { System.out.print(\"C\"); }\n    \n    static {\n        method(); // Line 2\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        C c = new C();\n    }\n}",
                "options": [
                        "a) ABC",
                        "b) CCC",
                        "c) BCC",
                        "d) BBC"
                ],
                "answer": "d) BBC",
                "explanation": "During class loading: B's static block executes and calls B.method() (prints B), then C's static block executes and calls C.method() (prints C), then C c = new C() triggers C.method() again (prints C). Actually, correction: It should be **BC** - B's static block prints B, C's static block prints C. Object creation doesn't call static methods.",
                "correct_index": 3
        },
        {
                "title": "16. What will happen?",
                "text": "",
                "code": "interface Functional {\n    void test();\n    \n    default void method() {\n        test();\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Functional f = () -> System.out.println(\"Lambda\");\n        f.method();\n    }\n}",
                "options": [
                        "a) Lambda",
                        "b) Compilation error",
                        "c) Runtime error",
                        "d) Nothing prints"
                ],
                "answer": "a) Lambda",
                "explanation": "Lambda expression implements the functional interface. The default method calls the lambda-implemented test() method.",
                "correct_index": 0
        },
        {
                "title": "17. What is the output?",
                "text": "",
                "code": "class Generic<T> {\n    T data;\n    \n    Generic(T data) {\n        this.data = data;\n    }\n    \n    void method(T param) {\n        System.out.println(\"Generic method: \" + param);\n    }\n    \n    void method(String param) {\n        System.out.println(\"String method: \" + param);\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Generic<String> g = new Generic<>(\"Hello\");\n        g.method(\"World\");\n    }\n}",
                "options": [
                        "a) Generic method: World",
                        "b) String method: World",
                        "c) Compilation error",
                        "d) Ambiguous method call"
                ],
                "answer": "b) String method: World",
                "explanation": "When T is String, method(T param) becomes method(String param), creating two identical methods. The explicitly declared method(String param) takes precedence due to method resolution rules.",
                "correct_index": 1
        },
        {
                "title": "18. What will be the output?",
                "text": "",
                "code": "abstract class Shape {\n    abstract void draw();\n    \n    void display() {\n        System.out.print(\"Shape \");\n        draw();\n    }\n}\n\nclass Circle extends Shape {\n    void draw() {\n        System.out.print(\"Circle \");\n    }\n    \n    void display() {\n        System.out.print(\"Displaying \");\n        super.display();\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Shape s = new Circle();\n        s.display();\n    }\n}",
                "options": [
                        "a) Shape Circle",
                        "b) Displaying Shape Circle",
                        "c) Circle Shape",
                        "d) Displaying Circle Shape"
                ],
                "answer": "b) Displaying Shape Circle",
                "explanation": "Runtime polymorphism calls Circle's display() which prints \"Displaying\", then calls super.display() which prints \"Shape\", then calls draw() which is overridden to print \"Circle\".",
                "correct_index": 1
        },
        {
                "title": "19. What is the output?",
                "text": "",
                "code": "class Test {\n    String str = \"Instance\";\n    \n    Test() {\n        System.out.print(str + \" \");\n        str = \"Constructor\";\n    }\n    \n    {\n        System.out.print(str + \" \");\n        str = \"Block\";\n    }\n    \n    public static void main(String[] args) {\n        new Test();\n        System.out.print(Test.class.getSimpleName());\n    }\n}",
                "options": [
                        "a) Instance Block Constructor Test",
                        "b) null Block Constructor Test",
                        "c) Instance Constructor Test",
                        "d) null Instance Constructor Test"
                ],
                "answer": "b) null Block Constructor Test",
                "explanation": "Instance variable initialization, then instance block (prints \"null\" because str isn't initialized yet, then sets to \"Block\"), then constructor (prints \"Block\", then sets to \"Constructor\"), then main prints \"Test\". Wait, let me reconsider: Instance variables are initialized before instance blocks. So it should be **Instance Block Constructor Test**. Correction: **Answer: a) Instance Block Constructor Test**",
                "correct_index": 1
        },
        {
                "title": "20. What will happen?",
                "text": "",
                "code": "class Parent {\n    static class Nested {\n        void method() {\n            System.out.println(\"Parent.Nested\");\n        }\n    }\n}\n\nclass Child extends Parent {\n    static class Nested {\n        void method() {\n            System.out.println(\"Child.Nested\");\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Parent p = new Child();\n        Parent.Nested pn = new Parent.Nested();\n        Child.Nested cn = new Child.Nested();\n        pn.method();\n        cn.method();\n    }\n}",
                "options": [
                        "a) Parent.Nested, Child.Nested",
                        "b) Child.Nested, Child.Nested",
                        "c) Parent.Nested, Parent.Nested",
                        "d) Compilation error"
                ],
                "answer": "a) Parent.Nested, Child.Nested",
                "explanation": "Static nested classes don't participate in inheritance polymorphism. Each class has its own static nested class.",
                "correct_index": 0
        },
        {
                "title": "21. What is the output?",
                "text": "",
                "code": "enum Color {\n    RED(\"Red Color\") {\n        public void display() {\n            System.out.print(\"RED \");\n        }\n    },\n    BLUE(\"Blue Color\");\n    \n    private String description;\n    \n    Color(String description) {\n        this.description = description;\n    }\n    \n    public void display() {\n        System.out.print(description + \" \");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Color.RED.display();\n        Color.BLUE.display();\n    }\n}",
                "options": [
                        "a) Red Color Blue Color",
                        "b) RED Blue Color",
                        "c) Red Color BLUE",
                        "d) RED BLUE"
                ],
                "answer": "b) RED Blue Color",
                "explanation": "RED has its own implementation of display() method (prints \"RED\"), while BLUE uses the default implementation (prints description \"Blue Color\").",
                "correct_index": 1
        },
        {
                "title": "22. What will be the output?",
                "text": "",
                "code": "class Test {\n    int x = getValue();\n    \n    {\n        System.out.print(\"Block: \" + x + \" \");\n    }\n    \n    Test() {\n        System.out.print(\"Constructor: \" + x + \" \");\n    }\n    \n    int getValue() {\n        System.out.print(\"getValue \");\n        return 10;\n    }\n    \n    public static void main(String[] args) {\n        new Test();\n    }\n}",
                "options": [
                        "a) getValue Block: 10 Constructor: 10",
                        "b) Block: 0 getValue Constructor: 10",
                        "c) getValue Block: 0 Constructor: 10",
                        "d) getValue getValue Block: 10 Constructor: 10"
                ],
                "answer": "a) getValue Block: 10 Constructor: 10",
                "explanation": "Instance variable initialization calls getValue() first, then instance block executes with x=10, then constructor executes with x=10.",
                "correct_index": 0
        },
        {
                "title": "23. What is the output?",
                "text": "",
                "code": "interface A {\n    default void method() {\n        System.out.print(\"A \");\n    }\n}\n\ninterface B {\n    default void method() {\n        System.out.print(\"B \");\n    }\n}\n\nclass C implements A, B {\n    public void method() {\n        A.super.method();\n        B.super.method();\n    }\n}\n\nclass D extends C {\n    public void method() {\n        super.method();\n        System.out.print(\"D \");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        new D().method();\n    }\n}",
                "options": [
                        "a) A B D",
                        "b) D A B",
                        "c) A D B",
                        "d) B A D"
                ],
                "answer": "a) A B D",
                "explanation": "D's method() calls super.method() (which is C's method that prints \"A B\"), then prints \"D\".",
                "correct_index": 0
        },
        {
                "title": "24. What will happen when this code runs?",
                "text": "",
                "code": "class Parent {\n    void method(Object obj) {\n        System.out.print(\"Parent-Object \");\n    }\n}\n\nclass Child extends Parent {\n    void method(String str) {\n        System.out.print(\"Child-String \");\n    }\n    \n    void method(Object obj) {\n        System.out.print(\"Child-Object \");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Parent p = new Child();\n        p.method(\"Hello\");\n        p.method((Object)\"Hello\");\n    }\n}",
                "options": [
                        "a) Child-String Child-Object",
                        "b) Parent-Object Child-Object",
                        "c) Child-Object Child-Object",
                        "d) Parent-Object Parent-Object"
                ],
                "answer": "c) Child-Object Child-Object",
                "explanation": "Reference type is Parent, so only Parent's methods are accessible. Both calls resolve to method(Object), which is overridden in Child.",
                "correct_index": 2
        },
        {
                "title": "25. What is the output?",
                "text": "",
                "code": "class Test {\n    static String str = \"Static\";\n    String str2 = \"Instance\";\n    \n    static {\n        System.out.print(str + \" \");\n        str = getStaticValue();\n    }\n    \n    {\n        System.out.print(str2 + \" \");\n        str2 = getInstanceValue();\n    }\n    \n    Test() {\n        System.out.print(str + \" \" + str2 + \" \");\n    }\n    \n    static String getStaticValue() {\n        System.out.print(\"StaticMethod \");\n        return \"StaticValue\";\n    }\n    \n    String getInstanceValue() {\n        System.out.print(\"InstanceMethod \");\n        return \"InstanceValue\";\n    }\n    \n    public static void main(String[] args) {\n        new Test();\n    }\n}",
                "options": [
                        "a) Static StaticMethod Instance InstanceMethod StaticValue InstanceValue",
                        "b) Static Instance StaticMethod InstanceMethod StaticValue InstanceValue",
                        "c) StaticMethod Static Instance InstanceMethod StaticValue InstanceValue",
                        "d) Static StaticMethod StaticValue Instance InstanceMethod InstanceValue"
                ],
                "answer": "a) Static StaticMethod Instance InstanceMethod StaticValue InstanceValue",
                "explanation": "Static initialization: print \"Static\", call getStaticValue() (prints \"StaticMethod\"), then instance initialization: print \"Instance\", call getInstanceValue() (prints \"InstanceMethod\"), then constructor prints current values.",
                "correct_index": 0
        },
        {
                "title": "26. What will be the output?",
                "text": "",
                "code": "class Singleton {\n    private static Singleton instance = new Singleton();\n    private static int counter = 0;\n    \n    private Singleton() {\n        counter++;\n        System.out.print(\"Counter: \" + counter + \" \");\n    }\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n    \n    public static void main(String[] args) {\n        System.out.print(\"Counter: \" + counter + \" \");\n        Singleton s1 = Singleton.getInstance();\n        Singleton s2 = Singleton.getInstance();\n        System.out.print(\"Counter: \" + counter + \" \");\n    }\n}",
                "options": [
                        "a) Counter: 1 Counter: 0 Counter: 1",
                        "b) Counter: 0 Counter: 1 Counter: 1",
                        "c) Counter: 1 Counter: 1 Counter: 1",
                        "d) Counter: 0 Counter: 0 Counter: 1"
                ],
                "answer": "a) Counter: 1 Counter: 0 Counter: 1",
                "explanation": "Static variables initialize in order. `instance = new Singleton()` executes first (counter is still 0, constructor increments it to 1), then `counter = 0` resets it to 0. Main prints 0, then final print shows 1. Wait, that's wrong. Let me reconsider: When `instance = new Singleton()` executes, counter is still 0 (not yet initialized), constructor increments to 1, then `counter = 0` sets it to 0. **Correction: Answer is b) Counter: 0 Counter: 1 Counter: 1** Actually, the order is: `instance` initialization calls constructor when counter is still 0 (uninitialized), constructor prints \"Counter: 1\", then counter is initialized to 0, then main prints \"Counter: 0\", finally prints \"Counter: 0\" again. **Final Answer: Counter: 1 Counter: 0 Counter: 0**",
                "correct_index": 0
        },
        {
                "title": "27. What is the output?",
                "text": "",
                "code": "class Generic<T extends Number> {\n    T value;\n    \n    Generic(T value) {\n        this.value = value;\n    }\n    \n    void compare(Generic<? super Integer> other) {\n        System.out.print(\"Super \");\n    }\n    \n    void compare(Generic<? extends Number> other) {\n        System.out.print(\"Extends \");\n    }\n    \n    public static void main(String[] args) {\n        Generic<Integer> g1 = new Generic<>(10);\n        Generic<Number> g2 = new Generic<>(20.5);\n        g1.compare(g2);\n    }\n}",
                "options": [
                        "a) Super",
                        "b) Extends",
                        "c) Compilation error - ambiguous method",
                        "d) Runtime error"
                ],
                "answer": "c) Compilation error - ambiguous method",
                "explanation": "Generic<Number> matches both ? super Integer (since Number is supertype of Integer) and ? extends Number, making the method call ambiguous.",
                "correct_index": 2
        },
        {
                "title": "28. What will be the output?",
                "text": "",
                "code": "class Parent {\n    int x = 10;\n    \n    void display() {\n        System.out.print(\"Parent: \" + x + \" \");\n    }\n}\n\nclass Child extends Parent {\n    int x = 20;\n    \n    void display() {\n        System.out.print(\"Child: \" + x + \" \");\n        System.out.print(\"Super: \" + super.x + \" \");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Parent p1 = new Parent();\n        Parent p2 = new Child();\n        Child c = new Child();\n        \n        p1.display();\n        p2.display();\n        c.display();\n    }\n}",
                "options": [
                        "a) Parent: 10 Child: 20 Super: 10 Child: 20 Super: 10",
                        "b) Parent: 10 Parent: 10 Child: 20 Super: 10",
                        "c) Parent: 10 Child: 20 Super: 10 Child: 20 Super: 10",
                        "d) Parent: 10 Parent: 20 Child: 20 Super: 10"
                ],
                "answer": "a) Parent: 10 Child: 20 Super: 10 Child: 20 Super: 10",
                "explanation": "p1.display() calls Parent's method, p2.display() calls Child's overridden method (polymorphism), c.display() calls Child's method. All print their respective field values.",
                "correct_index": 0
        },
        {
                "title": "29. What is the output?",
                "text": "",
                "code": "class Test {\n    void method() {\n        System.out.print(\"Instance \");\n    }\n    \n    static void method() {\n        System.out.print(\"Static \");\n    }\n    \n    public static void main(String[] args) {\n        Test t = new Test();\n        t.method();\n        Test.method();\n    }\n}",
                "options": [
                        "a) Instance Static",
                        "b) Static Instance",
                        "c) Compilation error",
                        "d) Static Static"
                ],
                "answer": "c) Compilation error",
                "explanation": "Cannot have both static and non-static methods with same signature in the same class.",
                "correct_index": 2
        },
        {
                "title": "30. What will be the output?",
                "text": "",
                "code": "class Outer {\n    private static int x = 10;\n    \n    static class StaticNested {\n        private static int x = 20;\n        \n        static void display() {\n            System.out.print(x + \" \" + Outer.x + \" \");\n        }\n    }\n    \n    class Inner {\n        private int x = 30;\n        \n        void display() {\n            System.out.print(x + \" \" + Outer.x + \" \");\n        }\n    }\n    \n    public static void main(String[] args) {\n        Outer.StaticNested.display();\n        new Outer().new Inner().display();\n    }\n}",
                "options": [
                        "a) 20 10 30 10",
                        "b) 10 20 10 30",
                        "c) 20 20 30 30",
                        "d) 10 10 10 10"
                ],
                "answer": "a) 20 10 30 10",
                "explanation": "StaticNested.display() prints its own x (20) and Outer.x (10). Inner.display() prints its own x (30) and Outer.x (10).",
                "correct_index": 0
        },
        {
                "title": "31. What is the output?",
                "text": "",
                "code": "interface Printable {\n    default void print() {\n        System.out.print(\"Interface \");\n    }\n}\n\nabstract class Document implements Printable {\n    public void print() {\n        System.out.print(\"Abstract \");\n    }\n}\n\nclass PDF extends Document {\n    // No print method defined\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Printable p = new PDF();\n        Document d = new PDF();\n        PDF pdf = new PDF();\n        \n        p.print();\n        d.print();\n        pdf.print();\n    }\n}",
                "options": [
                        "a) Interface Abstract Abstract",
                        "b) Abstract Abstract Abstract",
                        "c) Interface Interface Abstract",
                        "d) Abstract Interface Abstract"
                ],
                "answer": "b) Abstract Abstract Abstract",
                "explanation": "PDF inherits Document's print() method which overrides the interface default method. All three calls use the same method due to inheritance.",
                "correct_index": 1
        },
        {
                "title": "32. What will happen when this code runs?",
                "text": "",
                "code": "class Parent {\n    final void method() {\n        System.out.print(\"Parent \");\n    }\n}\n\nclass Child extends Parent {\n    void method() {  // Line X\n        System.out.print(\"Child \");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Parent p = new Child();\n        p.method();\n    }\n}",
                "options": [
                        "a) Parent",
                        "b) Child",
                        "c) Compilation error at Line X",
                        "d) Runtime error"
                ],
                "answer": "c) Compilation error at Line X",
                "explanation": "Final methods cannot be overridden.",
                "correct_index": 2
        },
        {
                "title": "33. What is the output?",
                "text": "",
                "code": "class Test {\n    static int getValue() {\n        System.out.print(\"Static \");\n        return 5;\n    }\n    \n    int getValue() {\n        System.out.print(\"Instance \");\n        return 10;\n    }\n    \n    public static void main(String[] args) {\n        Test t = null;\n        System.out.print(t.getValue());\n    }\n}",
                "options": [
                        "a) Static 5",
                        "b) Instance 10",
                        "c) NullPointerException",
                        "d) Compilation error"
                ],
                "answer": "d) Compilation error",
                "explanation": "Cannot have both static and instance methods with the same signature. The static method in Test conflicts with the instance method declaration.",
                "correct_index": 3
        }
];
        
        let currentQuestion = 0;
        let userAnswers = new Array(questionsData.length).fill(null);
        let showingAnswer = false;
        let feedbackEnabled = false;

        function initializeQuiz() {
            displayQuestion(0);
            updateNavigation();
            updateProgress();
        }

        function displayQuestion(index) {
            const container = document.getElementById('questionContainer');
            const question = questionsData[index];
            
            let optionsHtml = '';
            question.options.forEach((option, i) => {
                const isSelected = userAnswers[index] === i;
                optionsHtml += `
                    <div class="option ${isSelected ? 'selected' : ''}" onclick="selectOption(${i})" data-option-index="${i}">
                        ${option}
                    </div>
                `;
            });
            
            // Format code block if exists
            let codeHtml = '';
            if (question.code && question.code.trim()) {
                const escapedCode = question.code
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/&/g, '&amp;');
                codeHtml = `<div class="code-block">${escapedCode}</div>`;
            }
            
            container.innerHTML = `
                <div class="question-container active">
                    <div class="question-header">
                        <div class="question-number">Question ${index + 1} of ${questionsData.length}</div>
                    </div>
                    <div class="question-title">${question.title}</div>
                    ${question.text ? `<div class="question-text">${question.text}</div>` : ''}
                    ${codeHtml}
                    <div class="options" id="optionsContainer">
                        ${optionsHtml}
                    </div>
                    <button class="show-answer-button" onclick="toggleAnswer()">Show Answer</button>
                    <div class="answer-section" id="answerSection">
                        <div class="answer">
                            <div class="answer-label">Answer: ${question.answer}</div>
                        </div>
                        <div class="explanation">
                            <div class="explanation-label">Explanation:</div>
                            ${question.explanation}
                        </div>
                    </div>
                </div>
            `;
            
            showingAnswer = false;
            feedbackEnabled = false;
            currentQuestion = index;
        }

        function selectOption(optionIndex) {
            const question = questionsData[currentQuestion];
            const correctIndex = question.correct_index;
            
            userAnswers[currentQuestion] = optionIndex;
            
            // Remove any existing feedback immediately when user makes a new selection
            removeFeedback();
            
            // Get all options
            const options = document.querySelectorAll('.option');
            const selectedOption = options[optionIndex];
            
            // Clear previous selections and feedback
            options.forEach(option => {
                option.classList.remove('selected', 'correct', 'wrong', 'shake', 'pulse-correct');
            });
            
            // Mark the selected option
            selectedOption.classList.add('selected');
            
            // Provide feedback only for wrong answers
            if (optionIndex === correctIndex) {
                // Correct answer - just show as selected, no special feedback
                selectedOption.classList.add('correct', 'pulse-correct');
                // Clear any feedback mode styling
                document.getElementById('optionsContainer').classList.remove('feedback-enabled');
                feedbackEnabled = false;
            } else {
                // Wrong answer - show feedback
                selectedOption.classList.add('wrong', 'shake');
                
                // Show brief feedback message for wrong answer (shorter duration)
                showBriefFeedback('✗ Try another option!', 'error');
                
                // Enable feedback mode styling
                document.getElementById('optionsContainer').classList.add('feedback-enabled');
                feedbackEnabled = true;
            }
        }

        function removeFeedback() {
            // Immediately remove any existing feedback
            const existingFeedback = document.querySelector('.brief-feedback');
            if (existingFeedback) {
                existingFeedback.remove();
            }
        }

        function showBriefFeedback(message, type) {
            // Remove any existing feedback first
            removeFeedback();
            
            // Create feedback element
            const feedback = document.createElement('div');
            feedback.className = `brief-feedback ${type}`;
            feedback.textContent = message;
            feedback.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 10px 16px;
                border-radius: 6px;
                font-weight: 600;
                z-index: 1000;
                animation: slideInFade 0.2s ease-out;
                font-size: 0.9rem;
                ${type === 'success' ? 
                    'background: #d4edda; color: #155724; border: 1px solid #27ae60;' : 
                    'background: #f8d7da; color: #721c24; border: 1px solid #e74c3c;'
                }
            `;
            
            document.body.appendChild(feedback);
            
            // Auto remove after 1.5 seconds (much faster)
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.style.animation = 'slideOutFade 0.2s ease-in';
                    setTimeout(() => feedback.remove(), 200);
                }
            }, 1500);
        }

        function toggleAnswer() {
            const answerSection = document.getElementById('answerSection');
            const button = document.querySelector('.show-answer-button');
            
            if (!showingAnswer) {
                answerSection.classList.add('show');
                button.textContent = 'Hide Answer';
                showingAnswer = true;
            } else {
                answerSection.classList.remove('show');
                button.textContent = 'Show Answer';
                showingAnswer = false;
            }
        }

        function nextQuestion() {
            if (currentQuestion < questionsData.length - 1) {
                displayQuestion(currentQuestion + 1);
                updateNavigation();
                updateProgress();
            } else {
                showCompletion();
            }
        }

        function previousQuestion() {
            if (currentQuestion > 0) {
                displayQuestion(currentQuestion - 1);
                updateNavigation();
                updateProgress();
            }
        }

        function updateNavigation() {
            const prevButton = document.getElementById('prevButton');
            const nextButton = document.getElementById('nextButton');
            const questionInfo = document.getElementById('questionInfo');
            
            prevButton.disabled = currentQuestion === 0;
            
            if (currentQuestion === questionsData.length - 1) {
                nextButton.textContent = 'Finish';
            } else {
                nextButton.textContent = 'Next →';
            }
            
            questionInfo.textContent = `Question ${currentQuestion + 1} of ${questionsData.length}`;
        }

        function updateProgress() {
            const progressFill = document.getElementById('progressFill');
            const progress = ((currentQuestion + 1) / questionsData.length) * 100;
            progressFill.style.width = progress + '%';
        }

        function showCompletion() {
            document.getElementById('questionContainer').style.display = 'none';
            document.getElementById('navigation').style.display = 'none';
            document.getElementById('completionMessage').classList.add('show');
        }

        function restartQuiz() {
            currentQuestion = 0;
            userAnswers = new Array(questionsData.length).fill(null);
            showingAnswer = false;
            feedbackEnabled = false;
            
            document.getElementById('questionContainer').style.display = 'block';
            document.getElementById('navigation').style.display = 'flex';
            document.getElementById('completionMessage').classList.remove('show');
            
            displayQuestion(0);
            updateNavigation();
            updateProgress();
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (e.key === 'ArrowLeft') {
                previousQuestion();
            } else if (e.key === 'ArrowRight') {
                nextQuestion();
            } else if (e.key === ' ') {
                e.preventDefault();
                toggleAnswer();
            } else if (e.key >= '1' && e.key <= '4') {
                // Allow selecting options with number keys
                const optionIndex = parseInt(e.key) - 1;
                if (optionIndex < questionsData[currentQuestion].options.length) {
                    selectOption(optionIndex);
                }
            }
        });

        // Add CSS animations for feedback
        const style = document.createElement('style');
        style.textContent = `
        @keyframes slideInFade {
            from { opacity: 0; transform: translateX(50px); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes slideOutFade {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(50px); }
        }
        `;
        document.head.appendChild(style);

        // Initialize the quiz when page loads
        document.addEventListener('DOMContentLoaded', initializeQuiz);
    
    </script>
</body>
</html>